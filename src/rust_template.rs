
use serde::de::value::BoolDeserializer;

use crate::yaml_parser::{self, ParameterType};
use std::io::{self, Write};
use std::fs::File;

fn map_inst_feed_rust(inst: &yaml_parser::InstFeedback) -> String {
    format!("{{{}}}",
        inst.parameters.iter().map(|v|
        format!("{}: {}", v.name, v.data_type.to_rust_type_string())).collect::<Vec<String>>().join(","))
}

const FILE_HEADER : &'static str = r#"// This file is autogenerated, please do not edit manually
use std::convert::TryInto;
use serde_derive::Serialize;
"#;

pub fn build_rust_source(file_name: String, codes: &yaml_parser::CodesFile) -> Result<(), io::Error> {
    let mut file = File::create(file_name)?;

    // Show some Rust code
    let parsed_codes = codes.codes.iter().map(|(k,v)| {
        let instruction = [v.name.clone(), v.instruction.iter().map(map_inst_feed_rust).collect::<Vec<String>>().join("")].join("");
        let feedback = [v.name.clone(), v.feedback.iter().map(map_inst_feed_rust).collect::<Vec<String>>().join("")].join("");

        (k, instruction, feedback)
    }
    ).collect::<Vec<_>>();


    file.write_all(FILE_HEADER.as_bytes())?;

    // First, create the enumerations declaration.
    file.write_all(r#"
#[derive(PartialEq, Eq, Clone, Serialize, Debug)]
pub enum Instructions {
    "#.as_bytes())?;

    file.write_all(codes.codes.iter().filter_map(|(_k, code)| {
        if let Some(inst) = &code.instruction { 
            Some(format!("{}{}", code.name, map_inst_feed_rust(&inst))) 
        } else {None}
}).collect::<Vec<String>>().join(",\n\t").as_bytes())?;

    file.write_all(r#"
}


#[derive(PartialEq, Eq, Clone, Serialize, Debug)]
pub enum Feedbacks {
    "#.as_bytes())?;

    file.write_all(codes.codes.iter().filter_map(|(_k, code)| {
        if let Some(inst) = &code.feedback { 
            Some(format!("{}{}", code.name, map_inst_feed_rust(&inst))) 
        } else {None}
}).collect::<Vec<String>>().join(",\n\t").as_bytes())?;

    file.write_all(r#"
}



"#.as_bytes())?;


    // Add to frame implementation
    file.write_all(r#"
impl Feedbacks {
    pub fn to_bytes(self) -> Vec<u8> {
        match self {
            "#.as_bytes())?;

    file.write_all(&codes.codes.iter().filter_map(|(&id, code)| {
        if let Some(code_fb) = &code.feedback {
            let params = &code_fb.parameters.iter().map(|param| {
                [
                    match param.data_type {
                        ParameterType::Bool => "&[if ".as_bytes(),
                        ParameterType::Int8 |
                        ParameterType::Uint8 => "&[".as_bytes(),
                        ParameterType::String => "".as_bytes(),
                        _ => "&".as_bytes()
                    },
                    param.name.as_bytes(),
                match param.data_type {
                    ParameterType::Uint8 => "] as &[u8]".as_bytes(),
                    ParameterType::Bool => " {1u8} else {0u8}]".as_bytes(),
                    ParameterType::Uint16 |
                    ParameterType::Uint32 |
                    ParameterType::Uint64 |
                    ParameterType::Int64 |
                    ParameterType::Int32 |
                    ParameterType::Int16 => ".to_le_bytes()".as_bytes(),
                    ParameterType::Int8 => " as u8]".as_bytes(),
                    ParameterType::String => ".as_bytes()".as_bytes()
                }
                ].concat()
            }).collect::<Vec<Vec<u8>>>().join(",".as_bytes());

            Some(
            [format!("Self::{}{{{}}} => vec![&[{}u8] as &[u8],",
            &code.name,
            code_fb.parameters.iter().map(|p| p.name.clone()).collect::<Vec<String>>().join(","), id).as_bytes(), params.as_slice(), "].concat()".as_bytes()].concat())
        } else { None }
    }).collect::<Vec<Vec<u8>>>().join(",\n\t\t\t".as_bytes()).as_slice())?;


    file.write_all(r#"
        }
    }

    pub fn from_bytes(bytes: &[u8]) -> Result<Self, ()> {
        match bytes[0] {
            "#.as_bytes())?;

    file.write_all(&codes.codes.iter().filter_map(|(&id, code)| {
        if let Some(code_fb) = &code.feedback {
            let mut start = 1;
            let params_parsing = &code_fb.parameters.iter().map(|param| {
                let data_len =  match param.data_type {
                    ParameterType::Bool |  
                    ParameterType::Uint8 |
                    ParameterType::Int8  => 1,
                    ParameterType::Uint16 |
                    ParameterType::Int16  => 2,
                    ParameterType::Uint32 |
                    ParameterType::Int32 => 4,
                    ParameterType::Uint64 |
                    ParameterType::Int64 => 8,
                    ParameterType::String => -1
                };
                let res = [format!("let {} = ", param.name).as_bytes(),
                // Front content
                match param.data_type {
                    ParameterType::Uint16 |
                    ParameterType::Uint32 |
                    ParameterType::Uint64 |
                    ParameterType::Int64 |
                    ParameterType::Int32 |
                    ParameterType::Int16 => format!("{}::from_le_bytes(", param.data_type.to_rust_type_string()),
                    ParameterType::String => "String::from_utf8(".into(),
                    _ => "".into()
                }.as_bytes(),
                match data_len {
                    -1 => format!("bytes[{}..]", start),
                    1 => format!("bytes[{}]", start),
                    _ =>  format!("bytes[{}..{}]", start, start+data_len),
                }.as_bytes(),
                // Back content
                match param.data_type {
                    ParameterType::Uint16 |
                    ParameterType::Uint32 |
                    ParameterType::Uint64 |
                    ParameterType::Int64 |
                    ParameterType::Int32 |
                    ParameterType::Int16 => ".try_into().unwrap())".as_bytes(),
                    ParameterType::String => ".to_vec()).unwrap()".as_bytes(),
                    ParameterType::Int8 => " as i8".as_bytes(),
                    ParameterType::Bool => " != 0u8".as_bytes(),
                    _ => "".as_bytes()
                },
                ";\n".as_bytes()
                ].concat();
                start = start + data_len;
                res
            }).collect::<Vec<Vec<u8>>>().join("\t\t\t\t".as_bytes());

            let params = &code_fb.parameters.iter().map(|param| {
                format!("{}{}{}",
                if let ParameterType::Bool = param.data_type { "if "} else {""},
                param.name,
                match param.data_type {
                    ParameterType::Uint8 => "",
                    ParameterType::Uint16 |
                    ParameterType::Uint32 |
                    ParameterType::Uint64 |
                    ParameterType::Int64 |
                    ParameterType::Int32 |
                    ParameterType::Int16 => ".to_le_bytes()",
                    ParameterType::Int8 => " as u8",
                    ParameterType::Bool => " {{ 1u8 }} else {{ 0u8 }}", 
                    ParameterType::String => ".as_bytes()"
                }).as_bytes().into()
            }).collect::<Vec<Vec<u8>>>().join(",".as_bytes());

            Some(
            format!(r#"{}u8 => {{
                {}
                Ok(Self::{}{{{}}})
            }}
                "#,
            id.to_string(),
            String::from_utf8(params_parsing.clone()).unwrap(),
            &code.name,
            code_fb.parameters.iter().map(|name| name.name.clone()).collect::<Vec<String>>().join(", ")))
        } else { None }
    }).collect::<Vec<String>>().join(",\n\t\t\t").as_bytes())?;

    file.write_all(r#",
    _ => Err(())
        }
    }
}

impl Instructions {
    pub fn to_bytes(self) -> Vec<u8> {
        match self {
    "#.as_bytes())?;


    file.write_all(&codes.codes.iter().filter_map(|(&id, code)| {
        if let Some(code_fb) = &code.instruction {
            let params = &code_fb.parameters.iter().map(|param| {
                [
                    match param.data_type {
                        ParameterType::Int8 |
                        ParameterType::Uint8 => "&[".as_bytes(),
                        ParameterType::Bool => "&[if ".as_bytes(),
                        ParameterType::String => "".as_bytes(),
                        _ => "&".as_bytes()
                    },
                    param.name.as_bytes(),
                match param.data_type {
                    ParameterType::Uint8 => "] as &[u8]".as_bytes(),
                    ParameterType::Bool => " {1u8} else {0u8}]".as_bytes(),
                    ParameterType::Uint16 |
                    ParameterType::Uint32 |
                    ParameterType::Uint64 |
                    ParameterType::Int64 |
                    ParameterType::Int32 |
                    ParameterType::Int16 => ".to_le_bytes()".as_bytes(),
                    ParameterType::Int8 => " as u8]".as_bytes(),
                    ParameterType::String => ".as_bytes()".as_bytes()
                }
                ].concat()
            }).collect::<Vec<Vec<u8>>>().join(",".as_bytes());

            Some(
            [format!("Self::{}{{{}}} => vec![&[{}u8] as &[u8],",
            &code.name,
            code_fb.parameters.iter().map(|p| p.name.clone()).collect::<Vec<String>>().join(","), id).as_bytes(), params.as_slice(), "].concat()".as_bytes()].concat())
        } else { None }
    }).collect::<Vec<Vec<u8>>>().join(",\n\t\t\t".as_bytes()).as_slice())?;


    file.write_all(r#"
        }
    }

    pub fn from_bytes(bytes: &[u8]) -> Result<Self, ()> {
        match bytes[0] {
            "#.as_bytes())?;

    file.write_all(&codes.codes.iter().filter_map(|(&id, code)| {
        if let Some(code_fb) = &code.instruction {
            let mut start = 1;
            let params_parsing = &code_fb.parameters.iter().map(|param| {
                let data_len =  match param.data_type {
                    ParameterType::Bool |
                    ParameterType::Uint8 |
                    ParameterType::Int8  => 1,
                    ParameterType::Uint16 |
                    ParameterType::Int16  => 2,
                    ParameterType::Uint32 |
                    ParameterType::Int32 => 4,
                    ParameterType::Uint64 |
                    ParameterType::Int64 => 8,
                    ParameterType::String => -1
                };
                let res = [format!("let {} = ", param.name).as_bytes(),
                // Front content
                match param.data_type {
                    ParameterType::Uint16 |
                    ParameterType::Uint32 |
                    ParameterType::Uint64 |
                    ParameterType::Int64 |
                    ParameterType::Int32 |
                    ParameterType::Int16 => format!("{}::from_le_bytes(", param.data_type.to_rust_type_string()),
                    ParameterType::String => "String::from_utf8(".into(),
                    _ => "".into()
                }.as_bytes(),
                match data_len {
                    -1 => format!("bytes[{}..]", start),
                    1 => format!("bytes[{}]", start),
                    _ =>  format!("bytes[{}..{}]", start, start+data_len),
                }.as_bytes(),
                // Back content
                match param.data_type {
                    ParameterType::Uint16 |
                    ParameterType::Uint32 |
                    ParameterType::Uint64 |
                    ParameterType::Int64 |
                    ParameterType::Int32 |
                    ParameterType::Int16 => ".try_into().unwrap())".as_bytes(),
                    ParameterType::String => ".to_vec()).unwrap()".as_bytes(),
                    ParameterType::Int8 => " as i8".as_bytes(),
                    ParameterType::Bool => " != 0u8".as_bytes(),
                    _ => "".as_bytes()
                },
                ";\n".as_bytes()
                ].concat();
                start = start + data_len;
                res
            }).collect::<Vec<Vec<u8>>>().join("\t\t\t\t".as_bytes());

            let params = &code_fb.parameters.iter().map(|param| {
                format!("{}{}{}",
                if let ParameterType::Bool = param.data_type { "if "} else {""},
                param.name,
                match param.data_type {
                    ParameterType::Uint8 => "",
                    ParameterType::Uint16 |
                    ParameterType::Uint32 |
                    ParameterType::Uint64 |
                    ParameterType::Int64 |
                    ParameterType::Int32 |
                    ParameterType::Int16 => ".to_le_bytes()",
                    ParameterType::Int8 => " as u8",
                    ParameterType::Bool => " {{ 1u8 }} else {{ 0u8 }}", 
                    ParameterType::String => ".as_bytes()"
                }).as_bytes().into()
            }).collect::<Vec<Vec<u8>>>().join(",".as_bytes());

            Some(
            format!(r#"{}u8 => {{
                {}
                Ok(Self::{}{{{}}})
            }}
                "#,
            id.to_string(),
            String::from_utf8(params_parsing.clone()).unwrap(),
            &code.name,
            code_fb.parameters.iter().map(|name| name.name.clone()).collect::<Vec<String>>().join(", ")))
        } else { None }
    }).collect::<Vec<String>>().join(",\n\t\t\t").as_bytes())?;

    file.write_all(r#",
    _ => Err(())
        }
    }
}
"#.as_bytes())?;

    Ok(())
}
