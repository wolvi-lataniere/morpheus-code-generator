use crate::{InstFeedback, InstFeedbackParameter, yaml_parser};
use std::fs::File;
use std::io::{self, Write};
use std::vec::Vec;

use crate::file_generator::FileGenerator;

const FILE_HEADER: &str = r#"
// This file is autogenerated, please do not edit manually
#include <stdint.h>
#include <stdbool.h>
#include <string.h>
#include <stdlib.h>

"#;

pub struct CppHeaderGenerator {
    file: Box<dyn Write>,
}

impl FileGenerator for CppHeaderGenerator {
    fn build_file(&mut self, codes: &yaml_parser::CodesFile) -> Result<(), io::Error> {
        self.write_header()?;

        self.declare_feedbacks(codes)?;
        self.declare_inscructions(codes)?;

        self.write_footer()?;
        self.file.flush()?;

        Ok(())
    }
}

impl CppHeaderGenerator {
    pub fn new(header_file_name: &String) -> Result<Self, io::Error> {
        Ok(CppHeaderGenerator {
            file: Box::new(File::create(header_file_name)?),
        })
    }

    fn write_header(&mut self) -> Result<(), io::Error> {
        self.file.write_all(FILE_HEADER.as_bytes())?;
        Ok(())
    }

    fn declare_feedbacks(&mut self, parameters: &yaml_parser::CodesFile) -> Result<(), io::Error> {
        self.declare_feedback_enum(parameters)?;
        self.declare_feedback_structures(parameters);
        self.declare_feedbacks_functions(parameters);
        Ok(())
    }

    fn declare_feedback_enum(&mut self, parameters: &crate::CodesFile) -> Result<(), io::Error> {
        self.write_enumerations_header("Feedbacks")?;
        self.file.write_all(
            self.get_formatted_enumeration_codes(&parameters.get_feedbacks(), "FB")
                .as_bytes(),
        )?;
        self.write_enumerations_footer("Feedbacks")?;
        Ok(())
    }

    fn declare_feedback_structures(&mut self, parameters: &crate::CodesFile) {
        parameters
            .get_feedbacks()
            .iter()
            .for_each(|(_, name, params)| self.create_parameters_structure(name, params, "fb"));
    }

    fn declare_inscructions(
        &mut self,
        parameters: &yaml_parser::CodesFile,
    ) -> Result<(), io::Error> {
        self.declare_instructions_enum(parameters)?;

        self.declare_instructions_structures(parameters);

        self.declare_instructions_functions(parameters);
        Ok(())
    }

    fn declare_instructions_enum(
        &mut self,
        parameters: &crate::CodesFile,
    ) -> Result<(), io::Error> {
        self.write_enumerations_header("Instructions")?;
        self.file.write_all(
            self.get_formatted_enumeration_codes(&parameters.get_instructions(), "INST")
                .as_bytes(),
        )?;
        self.write_enumerations_footer("Instructions")?;
        Ok(())
    }

    fn declare_instructions_structures(&mut self, parameters: &crate::CodesFile) {
        parameters
            .get_instructions()
            .iter()
            .for_each(|(_, name, params)| self.create_parameters_structure(name, params, "inst"));
    }

    fn write_footer(&mut self) -> Result<(), io::Error> {
        self.file.write_all(
            r#"

// External parsing functions
extern int parse_feedback_frame(char* buffer, int len, Feedbacks* code, void **parameters);
extern int parse_instruction_frame(char* buffer, int len, Instructions* code, void **parameters);"#
                .as_bytes(),
        )?;
        Ok(())
    }

    fn get_formatted_enumeration_codes(
        &self,
        parameters: &Vec<(u32, String, yaml_parser::InstFeedback)>,
        prefix: &str,
    ) -> String {
        parameters
            .iter()
            .map(|(instruction_code, name, _)| {
                format!("{}_{} = {}", prefix, name.to_uppercase(), instruction_code)
            })
            .collect::<Vec<String>>()
            .join(",\n\t")
    }

    fn write_enumerations_header(&mut self, enumeration_name: &str) -> Result<(), io::Error> {
        self.file.write_all(
            format!(
                r#"
// {} Codes list
typedef enum __{}_enum {{
    "#,
                enumeration_name,
                enumeration_name.to_lowercase()
            )
            .as_bytes(),
        )
    }

    fn write_enumerations_footer(&mut self, enumeration_name: &str) -> Result<(), io::Error> {
        self.file.write_all(
            format!(
                r#"
}} {enumeration_name};

"#
            )
            .as_bytes(),
        )
    }

    fn create_parameters_structure(
        &mut self,
        name: &str,
        parameters: &InstFeedback,
        struct_type: &str,
    ) {
        self.file
            .write_all(
                format!(
                    r#"
struct s_{}_{}_params {{
    {}
}};
"#,
                    struct_type,
                    name.to_lowercase(),
                    parameters
                        .parameters
                        .iter()
                        .map(|p| { p.c_parameter_definition_with_comment() })
                        .collect::<Vec<String>>()
                        .join("\n\t")
                )
                .as_bytes(),
            )
            .unwrap();
    }

    fn declare_feedbacks_functions(&mut self, codes: &crate::CodesFile) {
        codes.get_feedbacks().iter().for_each(|(_, name, _)| {
            self.declare_build_function(name, "feedback", "fb").unwrap();
        });
    }

    fn declare_instructions_functions(&mut self, codes: &crate::CodesFile) {
        codes.get_instructions().iter().for_each(|(_, name, _)| {
            self.declare_build_function(name, "instruction", "inst")
                .unwrap();
        });
    }

    fn declare_build_function(
        &mut self,
        name: &str,
        inst: &str,
        short: &str,
    ) -> Result<(), io::Error> {
        self.file.write_all(
            format!(
                r#"
int build_{inst}_{}_frame(char* buffer, int *len, struct s_{short}_{}_params* parameters);
"#,
                name.to_lowercase(),
                name.to_lowercase()
            )
            .as_bytes(),
        )
    }
}
