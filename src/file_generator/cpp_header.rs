use crate::{InstFeedback, yaml_parser};
use std::fs::File;
use std::io::{self, Write};
use std::vec::Vec;

use crate::file_generator::{FileGenerator, LanguageModel};

const FILE_HEADER: &str = r#"
// This file is autogenerated, please do not edit manually
#include <stdint.h>
#include <stdbool.h>
#include <string.h>
#include <stdlib.h>

"#;

pub struct CppHeaderGenerator {
    file: Box<dyn Write>,
}

impl FileGenerator for CppHeaderGenerator {
    fn build_file(&mut self, codes: &yaml_parser::CodesFile) -> Result<(), io::Error> {
        self.file.write_all(
            [
                self.file_header(),
                self.declare_instructions(codes),
                self.declare_feedbacks(codes),
            ]
            .join("")
            .as_bytes(),
        )?;

        self.write_footer()?;
        self.file.flush()?;

        Ok(())
    }
}

impl LanguageModel for CppHeaderGenerator {
    fn file_header(&self) -> String {
        FILE_HEADER.to_string()
    }

    fn implement_instructions(&self, _codes: &yaml_parser::CodesFile) -> String {
        String::new()
    }
    fn implement_feedbacks(&self, _codes: &yaml_parser::CodesFile) -> String {
        String::new()
    }

    fn declare_instructions(&self, codes: &yaml_parser::CodesFile) -> String {
        [
            self.declare_instructions_enum(codes),
            self.declare_instructions_structures(codes),
            self.declare_instructions_functions(codes),
        ]
        .join("")
    }

    fn declare_feedbacks(&self, codes: &yaml_parser::CodesFile) -> String {
        [
            self.declare_feedback_enum(codes),
            self.declare_feedback_structures(codes),
            self.declare_feedbacks_functions(codes),
        ]
        .join("")
    }
}

impl CppHeaderGenerator {
    pub fn new(header_file_name: &String) -> Result<Self, io::Error> {
        Ok(CppHeaderGenerator {
            file: Box::new(File::create(header_file_name)?),
        })
    }

    fn declare_feedback_enum(&self, parameters: &crate::CodesFile) -> String {
        [
            self.enumerations_header("Feedbacks"),
            self.get_formatted_enumeration_codes(&parameters.get_feedbacks(), "FB"),
            self.enumerations_footer("Feedbacks"),
        ]
        .join("")
    }

    fn declare_feedback_structures(&self, parameters: &crate::CodesFile) -> String {
        parameters
            .get_feedbacks()
            .iter()
            .map(|(_, name, params)| self.create_parameters_structure(name, params, "fb"))
            .collect::<String>()
    }

    fn declare_instructions_enum(&self, parameters: &crate::CodesFile) -> String {
        [
            self.enumerations_header("Instructions"),
            self.get_formatted_enumeration_codes(&parameters.get_instructions(), "INST"),
            self.enumerations_footer("Instructions"),
        ]
        .join("")
    }

    fn declare_instructions_structures(&self, parameters: &crate::CodesFile) -> String {
        parameters
            .get_instructions()
            .iter()
            .map(|(_, name, params)| self.create_parameters_structure(name, params, "inst"))
            .collect::<String>()
    }

    fn write_footer(&mut self) -> Result<(), io::Error> {
        self.file.write_all(
            r#"

// External parsing functions
extern int parse_feedback_frame(char* buffer, int len, Feedbacks* code, void **parameters);
extern int parse_instruction_frame(char* buffer, int len, Instructions* code, void **parameters);"#
                .as_bytes(),
        )?;
        Ok(())
    }

    fn get_formatted_enumeration_codes(
        &self,
        parameters: &Vec<(u32, String, yaml_parser::InstFeedback)>,
        prefix: &str,
    ) -> String {
        parameters
            .iter()
            .map(|(instruction_code, name, _)| {
                format!("{}_{} = {}", prefix, name.to_uppercase(), instruction_code)
            })
            .collect::<Vec<String>>()
            .join(",\n\t")
    }

    fn enumerations_header(&self, enumeration_name: &str) -> String {
        format!(
            r#"
// {} Codes list
typedef enum __{}_enum {{
    "#,
            enumeration_name,
            enumeration_name.to_lowercase()
        )
    }

    fn enumerations_footer(&self, enumeration_name: &str) -> String {
        format!(
            r#"
}} {enumeration_name};

"#
        )
    }

    fn create_parameters_structure(
        &self,
        name: &str,
        parameters: &InstFeedback,
        struct_type: &str,
    ) -> String {
        format!(
            r#"
struct s_{}_{}_params {{
    {}
}};
"#,
            struct_type,
            name.to_lowercase(),
            parameters
                .parameters
                .iter()
                .map(|p| { p.c_parameter_definition_with_comment() })
                .collect::<Vec<String>>()
                .join("\n\t")
        )
    }

    fn declare_feedbacks_functions(&self, codes: &crate::CodesFile) -> String {
        codes
            .get_feedbacks()
            .iter()
            .map(|(_, name, _)| self.declare_build_function(name, "feedback", "fb"))
            .collect::<String>()
    }

    fn declare_instructions_functions(&self, codes: &crate::CodesFile) -> String {
        codes
            .get_instructions()
            .iter()
            .map(|(_, name, _)| self.declare_build_function(name, "instruction", "inst"))
            .collect::<String>()
    }

    fn declare_build_function(&self, name: &str, inst: &str, short: &str) -> String {
        format!(
            r#"
int build_{inst}_{}_frame(char* buffer, int *len, struct s_{short}_{}_params* parameters);
"#,
            name.to_lowercase(),
            name.to_lowercase()
        )
    }
}
