// This file is autogenerated, please do not edit manually
use serde_derive::Serialize;
use std::{convert::TryInto, fmt};

#[derive(PartialEq, Debug)]
enum TypesEnum {
    U8(u8),
    I8(i8),
    U16(u16),
    I16(i16),
    U32(u32),
    I32(i32),
    U64(u64),
    I64(i64),
    Bool(bool),
    Str(String),
}

#[derive(Debug)]
pub enum TypesEnumError {
    TooShort,
    NoStringTerminationFound,
    FailedToDecodeString,
    UnknownCode,
}

impl TypesEnum {
    pub fn size(&self) -> usize {
        match self {
            Self::Bool(_) | Self::U8(_) | Self::I8(_) => 1,
            Self::U16(_) | Self::I16(_) => 2,
            Self::U32(_) | Self::I32(_) => 4,
            Self::U64(_) | Self::I64(_) => 8,
            Self::Str(a) => a.len() + 1,
        }
    }

    pub fn u8_from_buffer(buffer: &[u8]) -> Result<(u8, &[u8]), TypesEnumError> {
        if buffer.len() < Self::U8(0).size() {
            Err(TypesEnumError::TooShort)
        } else {
            Ok((
                u8::from_le_bytes(buffer[0..1].try_into().unwrap()),
                &buffer[1..],
            ))
        }
    }

    pub fn i8_from_buffer(buffer: &[u8]) -> Result<(i8, &[u8]), TypesEnumError> {
        if buffer.len() < Self::I8(0).size() {
            Err(TypesEnumError::TooShort)
        } else {
            Ok((
                i8::from_le_bytes(buffer[0..1].try_into().unwrap()),
                &buffer[1..],
            ))
        }
    }

    pub fn u16_from_buffer(buffer: &[u8]) -> Result<(u16, &[u8]), TypesEnumError> {
        if buffer.len() < Self::U16(0).size() {
            Err(TypesEnumError::TooShort)
        } else {
            Ok((
                u16::from_le_bytes(buffer[0..2].try_into().unwrap()),
                &buffer[2..],
            ))
        }
    }

    pub fn i16_from_buffer(buffer: &[u8]) -> Result<(i16, &[u8]), TypesEnumError> {
        if buffer.len() < Self::I16(0).size() {
            Err(TypesEnumError::TooShort)
        } else {
            Ok((
                i16::from_le_bytes(buffer[0..2].try_into().unwrap()),
                &buffer[2..],
            ))
        }
    }

    pub fn u32_from_buffer(buffer: &[u8]) -> Result<(u32, &[u8]), TypesEnumError> {
        if buffer.len() < Self::U32(0).size() {
            Err(TypesEnumError::TooShort)
        } else {
            Ok((
                u32::from_le_bytes(buffer[0..4].try_into().unwrap()),
                &buffer[4..],
            ))
        }
    }

    pub fn i32_from_buffer(buffer: &[u8]) -> Result<(i32, &[u8]), TypesEnumError> {
        if buffer.len() < Self::I32(0).size() {
            Err(TypesEnumError::TooShort)
        } else {
            Ok((
                i32::from_le_bytes(buffer[0..4].try_into().unwrap()),
                &buffer[4..],
            ))
        }
    }

    pub fn u64_from_buffer(buffer: &[u8]) -> Result<(u64, &[u8]), TypesEnumError> {
        if buffer.len() < Self::U64(0).size() {
            Err(TypesEnumError::TooShort)
        } else {
            Ok((
                u64::from_le_bytes(buffer[0..8].try_into().unwrap()),
                &buffer[8..],
            ))
        }
    }

    pub fn i64_from_buffer(buffer: &[u8]) -> Result<(i64, &[u8]), TypesEnumError> {
        if buffer.len() < Self::I64(0).size() {
            Err(TypesEnumError::TooShort)
        } else {
            Ok((
                i64::from_le_bytes(buffer[0..8].try_into().unwrap()),
                &buffer[8..],
            ))
        }
    }

    pub fn bool_from_buffer(buffer: &[u8]) -> Result<(bool, &[u8]), TypesEnumError> {
        if buffer.len() < Self::Bool(false).size() {
            Err(TypesEnumError::TooShort)
        } else {
            Ok((buffer[0] != 0, &buffer[1..]))
        }
    }

    pub fn string_from_buffer(buffer: &[u8]) -> Result<(String, &[u8]), TypesEnumError> {
        let termination = buffer.iter().position(|v| *v == 0u8);
        match termination {
            None => Err(TypesEnumError::NoStringTerminationFound),
            Some(index) => {
                let string = String::from_utf8(buffer[..index].to_vec());
                if let Ok(string) = string {
                    Ok((string, &buffer[index + 1..]))
                } else {
                    Err(TypesEnumError::FailedToDecodeString)
                }
            }
        }
    }
}

trait WriteToBuffer {
    fn write_to_buffer(&self) -> Vec<u8>;
}

impl WriteToBuffer for TypesEnum {
    fn write_to_buffer(&self) -> Vec<u8> {
        match self {
            Self::U8(v) => v.to_le_bytes().to_vec(),
            Self::I8(v) => v.to_le_bytes().to_vec(),
            Self::U16(v) => v.to_le_bytes().to_vec(),
            Self::I16(v) => v.to_le_bytes().to_vec(),
            Self::U32(v) => v.to_le_bytes().to_vec(),
            Self::I32(v) => v.to_le_bytes().to_vec(),
            Self::U64(v) => v.to_le_bytes().to_vec(),
            Self::I64(v) => v.to_le_bytes().to_vec(),
            Self::Bool(true) => vec![1],
            Self::Bool(false) => vec![0],
            Self::Str(v) => {
                let mut value = v.as_bytes().to_vec();
                value.push(0);
                value
            }
        }
    }
}

// ##FEEDBACKS_DECLARATIONS##

// ##INSTRUCTIONS_DECLARATIONS##

// ##FEEDBACKS_IMPLEMENTATION##

// ##INSTRUCTIONS_IMPLEMENTATION##
