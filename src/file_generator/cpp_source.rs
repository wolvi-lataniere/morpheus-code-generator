use crate::yaml_parser::{self, InstFeedback, ParameterType};
use std::fs::File;
use std::io::{self, Write};
use std::path::Path;
use std::vec::Vec;

use crate::file_generator::{FileGenerator, FrameType};

const FILE_HEADER: &str = r#"

// This file is autogenerated, please do not edit manually
#include <stdint.h>
#include <string.h>
#include <stdlib.h>

"#;

pub struct CppFileGenerator {
    file: Box<dyn Write>,
    headerfile_name: String,
}

impl FileGenerator for CppFileGenerator {
    fn build_file(&mut self, codes: &yaml_parser::CodesFile) -> Result<(), io::Error> {
        self.write_header()?;

        codes.get_feedbacks().iter().for_each(|(k, name, inst)| {
            self.write_feedback_frame_builder(*k, name, inst).unwrap();
        });

        // Create a set of inline implementation for readability and debugging
        codes.get_instructions().iter().for_each(|(k, name, inst)| {
            self.write_instruction_frame_builder(*k, name, inst)
                .unwrap();
        });

        //     // Add to frame decoding
        // Create a set of inline implementation for readability and debugging
        codes.get_feedbacks().iter().for_each(|(k, name, fb)| {
            self.write_feedback_frame_parser(*k, name, fb).unwrap();
        });
        // Create a set of inline implementation for readability and debugging
        codes.get_instructions().iter().for_each(|(k, name, inst)| {
            self.write_instruction_frame_parser(*k, name, inst).unwrap();
        });

        self.write_feedback_frames_dispatch(codes)?;
        self.write_instruction_frames_dispatch(codes)?;

        Ok(())
    }
}

struct WriteFrameBuilder<'a> {
    builder_type: FrameType,
    key: String,
    name: &'a str,
    instruction: &'a InstFeedback,
}

impl<'a> WriteFrameBuilder<'a> {
    pub fn new(builder_type: FrameType, name: &'a str, instruction: &'a InstFeedback) -> Self {
        let builder_type_upper = builder_type.short().to_uppercase();
        let instruction_name_upper = name.to_uppercase();
        let key = format!("{builder_type_upper}_{instruction_name_upper}");
        WriteFrameBuilder {
            builder_type,
            key,
            name,
            instruction,
        }
    }

    pub fn build_frame(&self, file: &mut Box<dyn Write>) -> Result<(), io::Error> {
        let lowercase_name = self.name.to_lowercase();
        let key = &self.key;
        let type_long = self.builder_type.long();
        let type_short = self.builder_type.short();

        file.write_all(
            format!(
                r#"
int build_{type_long}_{lowercase_name}_frame(char* buffer, int *len, struct s_{type_short}_{lowercase_name}_params* parameters)
{{
    int position = 0;

    if ((buffer == NULL) || (len == NULL) || (parameters == NULL))
      return -1;
    
    if (position < *len) buffer[position++] = {key};
    else return -1;
        "#
            )
            .as_bytes(),
        )?;

        file.write_all(
            self.instruction
                .parameters
                .iter()
                .map(|p| match p.data_type {
                    ParameterType::Bool | ParameterType::Uint8 | ParameterType::Int8 => {
                        format!(
                            r#"
    if (position < *len) buffer[position++] = (uint8_t) parameters->{};
    else return -1;
    "#,
                            p.name
                        )
                    }
                    ParameterType::Int16
                    | ParameterType::Uint16
                    | ParameterType::Int32
                    | ParameterType::Uint32
                    | ParameterType::Int64
                    | ParameterType::Uint64 => format!(
                        r#"
    if ((position + {}) <= *len) {{
        memcpy(&buffer[position], &parameters->{}, {});
        position += {};
    }}
    else return -1;
    "#,
                        p.data_type.size(),
                        p.name,
                        p.data_type.size(),
                        p.data_type.size()
                    ),

                    ParameterType::String => format!(
                        r#"
    if (position < *len) {{
        int max_len= (*len) - position;
        int string_len = strlen(parameters->{});
        if (string_len>max_len) string_len=max_len;
        memcpy(&buffer[position], parameters->{}, string_len);
        position += string_len;
    }}
    else return -1;
                    "#,
                        p.name, p.name
                    ),
                })
                .collect::<Vec<String>>()
                .join("\n")
                .as_bytes(),
        )?;

        file.write_all(
            r#"
    *len = position;

    return 0;
}
        "#
            .as_bytes(),
        )
    }

    pub fn build_frame_parser(&self, file: &mut Box<dyn Write>) -> Result<(), io::Error> {
        let lowercase_name = self.name.to_lowercase();
        let key = &self.key;
        let inst = self.instruction;
        let type_long = self.builder_type.long();
        let type_short = self.builder_type.short();

        file.write_all(
            format!(
                r#"
int parse_{type_long}_{lowercase_name}_frame(char* buffer, int len, struct s_{type_short}_{lowercase_name}_params* parameters)
{{
    int position = 0;
    const size_t p_size = sizeof(struct s_{type_short}_{lowercase_name}_params);


    if (buffer == NULL)
        return -1;

    if ((p_size > 0) && (parameters == NULL))
        return -1;
        
    // Check the code
    if (buffer[position++] != {key}) return -1;
        "#
            )
            .as_bytes(),
        )?;

        file.write_all(
            inst.parameters
                .iter()
                .map(|p| match p.data_type {
                    ParameterType::Bool => format!(
                        r#"
    if (position < len) parameters->{} = (buffer[position++] != 0) ;
    else return -1;
    "#,
                        p.name
                    ),
                    ParameterType::Uint8 | ParameterType::Int8 => format!(
                        r#"
    if (position < len) parameters->{} = ({}) buffer[position++] ;
    else return -1;
    "#,
                        p.name,
                        p.data_type.to_cpp_type_string()
                    ),
                    ParameterType::Int16
                    | ParameterType::Uint16
                    | ParameterType::Int32
                    | ParameterType::Uint32
                    | ParameterType::Int64
                    | ParameterType::Uint64 => format!(
                        r#"
    if ((position + {}) <= len) {{
        memcpy(&parameters->{}, &buffer[position], {});
        position += {};
    }}
    else return -1;
    "#,
                        p.data_type.size(),
                        p.name,
                        p.data_type.size(),
                        p.data_type.size()
                    ),

                    ParameterType::String => format!(
                        r#"
    if (position < len) {{
        int copy_len = (len) - position;
        // free buffer if not null
        if (parameters->{} != NULL) k_free(parameters->{});
        parameters->{} = (char*)k_malloc(copy_len+1);
        strncpy(parameters->{}, &buffer[position], copy_len);
        parameters->{}[copy_len] = 0; // Ensure last character is null
        position += copy_len;
    }}
    else return -1;
                    "#,
                        p.name, p.name, p.name, p.name, p.name
                    ),
                })
                .collect::<Vec<String>>()
                .join("\n")
                .as_bytes(),
        )?;

        file.write_all(
            r#"
    return 0;
}
        "#
            .as_bytes(),
        )
    }

    pub fn build_dispatch_case(&self, file: &mut Box<dyn Write>) -> Result<(), io::Error> {
        let lowercase_name = self.name.to_lowercase();
        let uppercase_name = self.name.to_uppercase();
        let frametype_upper = self.builder_type.short().to_uppercase();
        let frametype_lower = self.builder_type.short();
        let frametype_long = self.builder_type.long();
        let key = format!("{frametype_upper}_{uppercase_name}");
        file
                .write_all(
                    format!(
                        r#"
        case {key}:
            {{
                const size_t psize = sizeof(struct s_{frametype_lower}_{lowercase_name}_params);
                *parameters = k_malloc(psize);
                memset(*parameters, 0, psize);
                *code = {frametype_upper}_{uppercase_name};
                return parse_{frametype_long}_{lowercase_name}_frame(buffer, len, (struct s_{frametype_lower}_{lowercase_name}_params*)*parameters);
            }}
        "#
                    )
                    .as_bytes(),
                )
    }
}

impl CppFileGenerator {
    pub fn new(
        source_file_name: &String,
        header_file: &Option<String>,
    ) -> Result<CppFileGenerator, io::Error> {
        //// Create source code file
        let file = File::create(source_file_name)?;

        let headerfile_name = Path::new(&header_file.clone().unwrap_or(source_file_name.clone()))
            .file_name()
            .unwrap()
            .to_str()
            .unwrap()
            .replace(".cpp", ".h")
            .replace(".c", ".h");

        Ok(CppFileGenerator {
            file: Box::new(file),
            headerfile_name,
        })
    }

    fn write_header(&mut self) -> Result<(), io::Error> {
        self.file.write_all(FILE_HEADER.as_bytes())?;
        self.file.write_all(
            format!(
                r#"#include "{}"
#include <zephyr/zephyr.h>
    "#,
                self.headerfile_name
            )
            .as_bytes(),
        )?;
        Ok(())
    }

    fn write_instruction_frame_builder(
        &mut self,
        _key: u32,
        name: &str,
        instruction: &InstFeedback,
    ) -> Result<(), io::Error> {
        WriteFrameBuilder::new(FrameType::Instruction, name, instruction)
            .build_frame(&mut self.file)
    }

    fn write_feedback_frame_builder(
        &mut self,
        _key: u32,
        name: &str,
        instruction: &InstFeedback,
    ) -> Result<(), io::Error> {
        WriteFrameBuilder::new(FrameType::Feedback, name, instruction).build_frame(&mut self.file)
    }

    fn write_feedback_frame_parser(
        &mut self,
        _key: u32,
        name: &str,
        fb: &InstFeedback,
    ) -> Result<(), io::Error> {
        WriteFrameBuilder::new(FrameType::Feedback, name, fb).build_frame_parser(&mut self.file)
    }

    fn write_instruction_frame_parser(
        &mut self,
        _key: u32,
        name: &str,
        inst: &InstFeedback,
    ) -> Result<(), io::Error> {
        WriteFrameBuilder::new(FrameType::Instruction, name, inst)
            .build_frame_parser(&mut self.file)
    }

    fn write_frames_dispatch(
        &mut self,
        builder_type: FrameType,
        instructions: Vec<(u32, String, InstFeedback)>,
    ) -> Result<(), io::Error> {
        let dispatch_type = builder_type.long();
        let struct_name = builder_type.struct_name();
        // To the frame decoding hub
        self.file.write_all(
            format!(
                r#"
int parse_{dispatch_type}_frame(char* buffer, int len, {struct_name}* code, void **parameters)
{{
    if ((buffer == NULL) || (code == NULL) || (parameters == NULL))
        return -3;

    switch (buffer[0])
    {{
    "#
            )
            .as_bytes(),
        )?;

        instructions.iter().for_each(|(_k, name, code)| {
            WriteFrameBuilder::new(builder_type, name, code)
                .build_dispatch_case(&mut self.file)
                .unwrap();
        });

        self.file.write_all(
            r#"
    default: 
        return -2;
    }
}

    "#
            .as_bytes(),
        )
    }

    fn write_feedback_frames_dispatch(
        &mut self,
        codes: &yaml_parser::CodesFile,
    ) -> Result<(), io::Error> {
        self.write_frames_dispatch(FrameType::Feedback, codes.get_feedbacks())
    }

    fn write_instruction_frames_dispatch(
        &mut self,
        codes: &yaml_parser::CodesFile,
    ) -> Result<(), io::Error> {
        self.write_frames_dispatch(FrameType::Instruction, codes.get_instructions())
    }
}
