
use crate::yaml_parser::{self, ParameterType};
use std::io::{self, Write};
use std::fs::File;
use std::path::Path;
use std::vec::Vec;

const FILE_HEADER : &'static str = r#"
// This file is autogenerated, please do not edit manually
#include <stdint.h>
#include <string.h>
#include <stdlib.h>

"#;

trait FileGenerator {
    fn write_header(&mut self) -> Result<(), io::Error>;
    fn write_enumerations(&mut self, parameters: Vec<(&u32, &yaml_parser::Codes)>) -> Result<(), io::Error>;
}

pub struct CppHeaderGenerator {
    file: Box<dyn Write>
}

impl FileGenerator for CppHeaderGenerator {
    fn write_header(&mut self) -> Result<(), io::Error>{
        self.file.write_all(FILE_HEADER.as_bytes())?;
        Ok(())
    }

    fn write_enumerations(&mut self, parameters: Vec<(&u32, &yaml_parser::Codes)>) -> Result<(), io::Error> {
        // First, create the enumerations declaration.
        self.file.write_all(r#"
// Instructions Codes list
typedef enum __instructions_enum {
    "#.as_bytes())?;

        self.file.write_all(parameters.iter().filter_map(|(k, v)| 
        if v.instruction.is_some() { Some(format!("INST_{} = {}", v.name.to_uppercase(), k)) }
        else { None }
    ).collect::<Vec<String>>().join(",\n\t").as_bytes())?;

        self.file.write_all(r#"
} Instructions;


// Feedback codes list
typedef enum __feedbacks_enum {
    "#.as_bytes())?;

        self.file.write_all(parameters.iter().filter_map(|(k, v)| 
        if v.feedback.is_some() { Some(format!("FB_{} = {}", v.name.to_uppercase(), k)) }
        else { None }
    ).collect::<Vec<String>>().join(",\n\t").as_bytes())?;

        self.file.write_all(r#"
} Feedbacks;


"#.as_bytes())?;
        Ok(())
    }
}

impl CppHeaderGenerator {

    pub fn new(header_file_name: &String) -> Result<Self, io::Error> {
        Ok(CppHeaderGenerator{
            file: Box::new(File::create(&header_file_name)?)
        })
    }

    fn create_parameters_structure(&mut self, parameters: &Option<yaml_parser::InstFeedback>, name: &String, struct_type: &str) -> () {
        if let Some(inst) = &parameters {
            self.file.write_all(format!(r#"
struct s_{}_{}_params {{
    {}
}};
"#, 
            struct_type,
            name.to_lowercase(),
            inst.parameters.iter().map(|p| {
                format!("{} {};", p.data_type.to_cpp_type_string(), p.name)
            }).collect::<Vec<String>>().join("\n\t")
        ).as_bytes()).unwrap();
        }
    }

    pub fn build_cpp_header(&mut self, codes: &yaml_parser::CodesFile) -> Result<(), io::Error> {
        self.write_header()?;

        self.write_enumerations(codes.codes.iter().collect())?;

        codes.codes.iter().for_each(|(_, c)| 
            self.create_parameters_structure(&c.instruction, &c.name, "inst")
        );

    
        codes.codes.iter().for_each(|(_, c)| 
            self.create_parameters_structure(&c.feedback, &c.name, "fb")
        );

    codes.codes.iter().for_each(|(_k,code)| {
        if code.feedback.is_some() {
            self.file.write_all(format!(r#"
int build_feedback_{}_frame(char* buffer, int *len, struct s_fb_{}_params* parameters);
"#, code.name.to_lowercase(), code.name.to_lowercase()).as_bytes()).unwrap();
        }
        if code.instruction.is_some() {
            self.file.write_all(format!(r#"
int build_instruction_{}_frame(char* buffer, int *len, struct s_inst_{}_params* parameters);
"#, code.name.to_lowercase(), code.name.to_lowercase()).as_bytes()).unwrap();
        }
    });

    self.file.write_all(r#"

    // External parsing functions
    extern int parse_feedback_frame(char* buffer, int len, Feedbacks* code, void **parameters);
    extern int parse_instruction_frame(char* buffer, int len, Instructions* code, void **parameters);"#.as_bytes())?;
    self.file.flush()?;

    Ok(())
}
}

pub fn build_cpp_source(source_file_name: &String, header_file: &Option<String>, codes: &yaml_parser::CodesFile) -> Result<(), io::Error> {
//// Create source code file
    let mut file = File::create(&source_file_name)?;

    file.write_all(FILE_HEADER.as_bytes())?;
    file.write_all(format!(r#"#include "{}"
#include <zephyr/zephyr.h>
"#, Path::new(&header_file.clone().unwrap_or(source_file_name.clone())).file_name().unwrap().to_str().unwrap().replace(".cpp", ".h").replace(".c", ".h")).as_bytes())?;
    
//     // Add to frame implementation
// Create a set of inline implementation for readability and debugging
    codes.codes.iter().for_each(|(k, code)| {
        if let Some(fb) = &code.feedback {
            file.write_all(format!(r#"
int build_feedback_{}_frame(char* buffer, int *len, struct s_fb_{}_params* parameters)
{{
    int position = 0;

    if ((buffer == NULL) || (len == NULL) || (parameters == NULL))
      return -1;
    
    if (position < *len) buffer[position++] = {};
    else return -1;
        "#,
            code.name.to_lowercase(),
            code.name.to_lowercase(),
            k
        ).as_bytes()).unwrap();

            file.write_all(fb.parameters.iter().map(|p| {
                match p.data_type {
                    ParameterType::Bool |
                    ParameterType::Uint8 |
                    ParameterType::Int8 => format!(r#"
    if (position < *len) buffer[position++] = (uint8_t) parameters->{};
    else return -1;
    "#, p.name),
                    ParameterType::Int16 |
                    ParameterType::Uint16 |
                    ParameterType::Int32 |
                    ParameterType::Uint32 |
                    ParameterType::Int64 |
                    ParameterType::Uint64 => format!(r#"
    if ((position + {}) < *len) {{
        memcpy(&buffer[position], &parameters->{}, {});
        position += {};
    }}
    else return -1;
    "#,
                    p.data_type.size(),
                    p.name, p.data_type.size(),
                    p.data_type.size()),

                    ParameterType::String =>format!(r#"
    if (position < *len) {{
        int max_len= (*len) - position;
        int string_len = strlen(parameters->{});
        if (string_len>max_len) string_len=max_len;
        memcpy(&buffer[position], parameters->{}, string_len);
        position += string_len;
    }}
    else return -1;
                    "#,
                    p.name,
                    p.name),

                }
                
            }).collect::<Vec<String>>().join("\n").as_bytes()).unwrap();

            file.write_all(r#"
    *len = position;

    return 0;
}
        "#.as_bytes()).unwrap();
    }
    });


    // Create a set of inline implementation for readability and debugging
    codes.codes.iter().for_each(|(k, code)| {
        if let Some(inst) = &code.instruction {
            file.write_all(format!(r#"
int build_instruction_{}_frame(char* buffer, int *len, struct s_inst_{}_params* parameters)
{{
    int position = 0;

    if ((buffer == NULL) || (len == NULL) || (parameters == NULL))
      return -1;
    
    if (position < *len) buffer[position++] = {};
    else return -1;
        "#,
            code.name.to_lowercase(),
            code.name.to_lowercase(),
            k
        ).as_bytes()).unwrap();

            file.write_all(inst.parameters.iter().map(|p| {
                match p.data_type {
                    ParameterType::Bool |
                    ParameterType::Uint8 |
                    ParameterType::Int8 => format!(r#"
    if (position < *len) buffer[position++] = (uint8_t) parameters->{};
    else return -1;
    "#, p.name),
                    ParameterType::Int16 |
                    ParameterType::Uint16 |
                    ParameterType::Int32 |
                    ParameterType::Uint32 |
                    ParameterType::Int64 |
                    ParameterType::Uint64 => format!(r#"
    if ((position + {}) < *len) {{
        memcpy(&buffer[position], &parameters->{}, {});
        position += {};
    }}
    else return -1;
    "#,
                    p.data_type.size(),
                    p.name, p.data_type.size(),
                    p.data_type.size()),

                    ParameterType::String =>format!(r#"
    if (position < *len) {{
        int max_len= (*len) - position;
        int string_len = strlen(parameters->{});
        if (string_len>max_len) string_len=max_len;
        memcpy(&buffer[position], parameters->{}, string_len);
        position += string_len;
    }}
    else return -1;
                    "#,
                    p.name,
                    p.name),

                }
                
            }).collect::<Vec<String>>().join("\n").as_bytes()).unwrap();

            file.write_all(r#"
    *len = position;

    return 0;
}
        "#.as_bytes()).unwrap();
    }
    });


//     // Add to frame decoding
// Create a set of inline implementation for readability and debugging
    codes.codes.iter().for_each(|(k, code)| {
        if let Some(fb) = &code.feedback {
            file.write_all(format!(r#"
int parse_feedback_{}_frame(char* buffer, int len, struct s_fb_{}_params* parameters)
{{
    int position = 0;
    const size_t p_size = sizeof(struct s_fb_{}_params);


    if (buffer == NULL)
        return -1;

    if ((p_size > 0) && (parameters == NULL))
        return -1;
        
    // Check the code
    if (buffer[position++] != {}) return -1;
        "#,
            code.name.to_lowercase(),
            code.name.to_lowercase(),
            code.name.to_lowercase(),
            k
        ).as_bytes()).unwrap();

            file.write_all(fb.parameters.iter().map(|p| {
                match p.data_type {
                    ParameterType::Bool =>
                    format!(r#"
    if (position < len) parameters->{} = (buffer[position++] != 0) ;
    else return -1;
    "#, p.name),
                    ParameterType::Uint8 |
                    ParameterType::Int8 => format!(r#"
    if (position < len) parameters->{} = ({}) buffer[position++] ;
    else return -1;
    "#, p.name, p.data_type.to_cpp_type_string()),
                    ParameterType::Int16 |
                    ParameterType::Uint16 |
                    ParameterType::Int32 |
                    ParameterType::Uint32 |
                    ParameterType::Int64 |
                    ParameterType::Uint64 => format!(r#"
    if ((position + {}) < len) {{
        memcpy(&parameters->{}, &buffer[position], {});
        position += {};
    }}
    else return -1;
    "#,
                    p.data_type.size(),
                    p.name, p.data_type.size(),
                    p.data_type.size()),

                    ParameterType::String =>format!(r#"
    if (position < len) {{
        int copy_len = (len) - position;
        // free buffer if not null
        if (parameters->{} != NULL) k_free(parameters->{});
        parameters->{} = (char*)k_malloc(copy_len+1);
        strncpy(parameters->{}, &buffer[position], copy_len);
        parameters->{}[copy_len] = 0; // Ensure last character is null
        position += copy_len;
    }}
    else return -1;
                    "#,
                    p.name,
                    p.name,
                    p.name,
                    p.name,
                    p.name),

                }
                
            }).collect::<Vec<String>>().join("\n").as_bytes()).unwrap();

            file.write_all(r#"
    return 0;
}
        "#.as_bytes()).unwrap();
    }
    });

    // Create a set of inline implementation for readability and debugging
    codes.codes.iter().for_each(|(k, code)| {
        if let Some(inst) = &code.instruction {
            file.write_all(format!(r#"
int parse_instruction_{}_frame(char* buffer, int len, struct s_inst_{}_params* parameters)
{{
    int position = 0;
    const size_t p_size = sizeof(struct s_inst_{}_params);


    if (buffer == NULL)
        return -1;

    if ((p_size > 0) && (parameters == NULL))
        return -1;

    // Check the code
    if (buffer[position++] != {}) return -1;
        "#,
            code.name.to_lowercase(),
            code.name.to_lowercase(),
            code.name.to_lowercase(),
            k
        ).as_bytes()).unwrap();

            file.write_all(inst.parameters.iter().map(|p| {
                match p.data_type {
                    ParameterType::Bool => format!(r#"
    if (position < len) parameters->{} = (buffer[position++] != 0);
    else return -1;
    "#, p.name),
                    ParameterType::Uint8 |
                    ParameterType::Int8 => format!(r#"
    if (position < len) parameters->{} = ({}) buffer[position++] ;
    else return -1;
    "#, p.name, p.data_type.to_cpp_type_string()),
                    ParameterType::Int16 |
                    ParameterType::Uint16 |
                    ParameterType::Int32 |
                    ParameterType::Uint32 |
                    ParameterType::Int64 |
                    ParameterType::Uint64 => format!(r#"
    if ((position + {}) < len) {{
        memcpy(&parameters->{}, &buffer[position], {});
        position += {};
    }}
    else return -1;
    "#,
                    p.data_type.size(),
                    p.name, p.data_type.size(),
                    p.data_type.size()),

                    ParameterType::String =>format!(r#"
    if (position < len) {{
        int copy_len = (len) - position;
        // free buffer if not null
        if (parameters->{} != NULL) k_free(parameters->{});
        parameters->{} = (char*)k_malloc(copy_len+1);
        strncpy(parameters->{}, &buffer[position], copy_len);
        parameters->{}[copy_len] = 0; // Ensure last character is null
        position += copy_len;
    }}
    else return -1;
                    "#,
                    p.name,
                    p.name,
                    p.name,
                    p.name,
                    p.name),

                }
                
            }).collect::<Vec<String>>().join("\n").as_bytes()).unwrap();

            file.write_all(r#"
    return 0;
}
        "#.as_bytes()).unwrap();
    }
    });


    /// To the frame decoding hub
    file.write_all(r#"
int parse_feedback_frame(char* buffer, int len, Feedbacks* code, void **parameters)
{
    if ((buffer == NULL) || (code == NULL) || (parameters == NULL))
        return -1;

    switch (buffer[0])
    {
    "#.as_bytes())?;

    codes.codes.iter().for_each(|(k, code)| {
        if code.feedback.is_some() {
            file.write_all(format!(r#"
        case {}:
            {{
                const size_t psize = sizeof(struct s_fb_{}_params);
                *parameters = k_malloc(psize);
                memset(*parameters, 0, psize);
                *code = FB_{};
                return parse_feedback_{}_frame(buffer, len, (struct s_fb_{}_params*)*parameters);
            }}
        "#, k, 
            code.name.to_lowercase(),
            code.name.to_uppercase(),
            code.name.to_lowercase(),
            code.name.to_lowercase()
        ).as_bytes()).unwrap();
        }
    });

    file.write_all(r#"
    default: 
        return -1;
    }
}

    "#.as_bytes())?;


    file.write_all(r#"
int parse_instruction_frame(char* buffer, int len, Instructions* code, void **parameters)
{
    if ((buffer == NULL) || (code == NULL) || (parameters == NULL))
        return -1;

    switch (buffer[0])
    {
    "#.as_bytes())?;

    codes.codes.iter().for_each(|(k, code)| {
        if code.instruction.is_some() {
            file.write_all(format!(r#"
        case {}:
            {{
                const size_t psize = sizeof(struct s_inst_{}_params);
                *parameters = k_malloc(psize);
                memset(*parameters, 0, psize);
                *code = INST_{};
                return parse_instruction_{}_frame(buffer, len, (struct s_inst_{}_params*)*parameters);
            }}
        "#, k, 
            code.name.to_lowercase(),
            code.name.to_uppercase(),
            code.name.to_lowercase(),
            code.name.to_lowercase()
        ).as_bytes()).unwrap();
        }
    });

    file.write_all(r#"
    default: 
        return -1;
    }
}

    "#.as_bytes())?;
    Ok(())
}
