
use crate::yaml_parser::{self, InstFeedbackParameterType};
use std::io::{self, Write};
use std::fs::File;
use std::path::Path;

const FILE_HEADER : &'static str = r#"
// This file is autogenerated, please do not edit manually
#include <stdint.h>
#include <string.h>
#include <stdlib.h>

"#;

pub fn build_cpp_header(header_file_name: &String, codes: &yaml_parser::CodesFile) -> Result<(), io::Error> {
    let mut file = File::create(&header_file_name)?;

    file.write_all(FILE_HEADER.as_bytes())?;

    // First, create the enumerations declaration.
    file.write_all(r#"
// Instructions Codes list
typedef enum __instructions_enum {
    "#.as_bytes())?;

    file.write_all(codes.codes.iter().filter_map(|(k, v)| 
       if v.instruction.is_some() { Some(format!("INST_{} = {}", v.name.to_uppercase(), k)) }
       else { None }
).collect::<Vec<String>>().join(",\n\t").as_bytes())?;

    file.write_all(r#"
} Instructions;


// Feedback codes list
typedef enum __feedbacks_enum {
    "#.as_bytes())?;

    file.write_all(codes.codes.iter().filter_map(|(k, v)| 
    if v.feedback.is_some() { Some(format!("FB_{} = {}", v.name.to_uppercase(), k)) }
    else { None }
).collect::<Vec<String>>().join(",\n\t").as_bytes())?;

    file.write_all(r#"
} Feedbacks;



"#.as_bytes())?;

    codes.codes.iter().for_each(|(_k, code)| {
        if let Some(inst) = &code.instruction {
            file.write_all(format!(r#"
struct s_inst_{}_params {{
    {}
}};
"#, 
                code.name.to_lowercase(),
                inst.parameters.iter().map(|p| {
                    format!("{} {};", p.data_type.to_cpp_type_string(), p.name)
                }).collect::<Vec<String>>().join("\n\t")
            ).as_bytes()).unwrap();
            }
        });

    
    codes.codes.iter().for_each(|(_k, code)| {
            if let Some(fb) = &code.feedback {
                file.write_all(format!(r#"
struct s_fb_{}_params {{
    {}
}};
    "#, 
                    code.name.to_lowercase(),
                    fb.parameters.iter().map(|p| {
                        format!("{} {};", p.data_type.to_cpp_type_string(), p.name)
                    }).collect::<Vec<String>>().join("\n\t")
                ).as_bytes()).unwrap();
                }
            });

    codes.codes.iter().for_each(|(_k,code)| {
        if code.feedback.is_some() {
            file.write_all(format!(r#"
int build_feedback_{}_frame(char* buffer, int *len, struct s_fb_{}_params* parameters);
"#, code.name.to_lowercase(), code.name.to_lowercase()).as_bytes()).unwrap();
        }
        if code.instruction.is_some() {
            file.write_all(format!(r#"
int build_instruction_{}_frame(char* buffer, int *len, struct s_inst_{}_params* parameters);
"#, code.name.to_lowercase(), code.name.to_lowercase()).as_bytes()).unwrap();
        }
    });

    file.write_all(r#"

    // External parsing functions
    extern int parse_feedback_frame(char* buffer, int len, Feedbacks* code, void **parameters);
    extern int parse_instruction_frame(char* buffer, int len, Instructions* code, void **parameters);"#.as_bytes())?;
    file.flush()?;

    Ok(())
}

pub fn build_cpp_source(source_file_name: &String, header_file: &Option<String>, codes: &yaml_parser::CodesFile) -> Result<(), io::Error> {
//// Create source code file
    let mut file = File::create(&source_file_name)?;

    file.write_all(FILE_HEADER.as_bytes())?;
    file.write_all(format!(r#"#include "{}"
"#, Path::new(&header_file.clone().unwrap_or(source_file_name.clone())).file_name().unwrap().to_str().unwrap().replace(".cpp", ".h").replace(".c", ".h")).as_bytes())?;
    
//     // Add to frame implementation
// Create a set of inline implementation for readability and debugging
    codes.codes.iter().for_each(|(k, code)| {
        if let Some(fb) = &code.feedback {
            file.write_all(format!(r#"
int build_feedback_{}_frame(char* buffer, int *len, struct s_fb_{}_params* parameters)
{{
    int position = 0;

    if ((buffer == NULL) || (len == NULL) || (parameters == NULL))
      return -1;
    
    if (position < *len) buffer[position++] = {};
    else return -1;
        "#,
            code.name.to_lowercase(),
            code.name.to_lowercase(),
            k
        ).as_bytes()).unwrap();

            file.write_all(fb.parameters.iter().map(|p| {
                match p.data_type {
                    InstFeedbackParameterType::Uint8 |
                    InstFeedbackParameterType::Int8 => format!(r#"
    if (position < *len) buffer[position++] = (uint8_t) parameters->{};
    else return -1;
    "#, p.name),
                    InstFeedbackParameterType::Int16 |
                    InstFeedbackParameterType::Uint16 |
                    InstFeedbackParameterType::Int32 |
                    InstFeedbackParameterType::Uint32 |
                    InstFeedbackParameterType::Int64 |
                    InstFeedbackParameterType::Uint64 => format!(r#"
    if ((position + {}) < *len) {{
        memcpy(&buffer[position], &parameters->{}, {});
        position += {};
    }}
    else return -1;
    "#,
                    p.data_type.size(),
                    p.name, p.data_type.size(),
                    p.data_type.size()),

                    InstFeedbackParameterType::String =>format!(r#"
    if (position < *len) {{
        int max_len= (*len) - position;
        int string_len = strlen(parameters->{});
        if (string_len>max_len) string_len=max_len;
        memcpy(&buffer[position], parameters->{}, string_len);
        position += string_len;
    }}
    else return -1;
                    "#,
                    p.name,
                    p.name),

                }
                
            }).collect::<Vec<String>>().join("\n").as_bytes()).unwrap();

            file.write_all(r#"
    *len = position;

    return 0;
}
        "#.as_bytes()).unwrap();
    }
    });


    // Create a set of inline implementation for readability and debugging
    codes.codes.iter().for_each(|(k, code)| {
        if let Some(inst) = &code.instruction {
            file.write_all(format!(r#"
int build_instruction_{}_frame(char* buffer, int *len, struct s_inst_{}_params* parameters)
{{
    int position = 0;

    if ((buffer == NULL) || (len == NULL) || (parameters == NULL))
      return -1;
    
    if (position < *len) buffer[position++] = {};
    else return -1;
        "#,
            code.name.to_lowercase(),
            code.name.to_lowercase(),
            k
        ).as_bytes()).unwrap();

            file.write_all(inst.parameters.iter().map(|p| {
                match p.data_type {
                    InstFeedbackParameterType::Uint8 |
                    InstFeedbackParameterType::Int8 => format!(r#"
    if (position < *len) buffer[position++] = (uint8_t) parameters->{};
    else return -1;
    "#, p.name),
                    InstFeedbackParameterType::Int16 |
                    InstFeedbackParameterType::Uint16 |
                    InstFeedbackParameterType::Int32 |
                    InstFeedbackParameterType::Uint32 |
                    InstFeedbackParameterType::Int64 |
                    InstFeedbackParameterType::Uint64 => format!(r#"
    if ((position + {}) < *len) {{
        memcpy(&buffer[position], &parameters->{}, {});
        position += {};
    }}
    else return -1;
    "#,
                    p.data_type.size(),
                    p.name, p.data_type.size(),
                    p.data_type.size()),

                    InstFeedbackParameterType::String =>format!(r#"
    if (position < *len) {{
        int max_len= (*len) - position;
        int string_len = strlen(parameters->{});
        if (string_len>max_len) string_len=max_len;
        memcpy(&buffer[position], parameters->{}, string_len);
        position += string_len;
    }}
    else return -1;
                    "#,
                    p.name,
                    p.name),

                }
                
            }).collect::<Vec<String>>().join("\n").as_bytes()).unwrap();

            file.write_all(r#"
    *len = position;

    return 0;
}
        "#.as_bytes()).unwrap();
    }
    });


//     // Add to frame decoding
// Create a set of inline implementation for readability and debugging
    codes.codes.iter().for_each(|(k, code)| {
        if let Some(fb) = &code.feedback {
            file.write_all(format!(r#"
int parse_feedback_{}_frame(char* buffer, int len, struct s_fb_{}_params* parameters)
{{
    int position = 0;

    if ((buffer == NULL) || (len == NULL) || (parameters == NULL))
    return -1;

    // Check the code
    if (buffer[position++] != {}) return -1;
        "#,
            code.name.to_lowercase(),
            code.name.to_lowercase(),
            k
        ).as_bytes()).unwrap();

            file.write_all(fb.parameters.iter().map(|p| {
                match p.data_type {
                    InstFeedbackParameterType::Uint8 |
                    InstFeedbackParameterType::Int8 => format!(r#"
    if (position < len) parameters->{} = ({}) buffer[position++] ;
    else return -1;
    "#, p.name, p.data_type.to_cpp_type_string()),
                    InstFeedbackParameterType::Int16 |
                    InstFeedbackParameterType::Uint16 |
                    InstFeedbackParameterType::Int32 |
                    InstFeedbackParameterType::Uint32 |
                    InstFeedbackParameterType::Int64 |
                    InstFeedbackParameterType::Uint64 => format!(r#"
    if ((position + {}) < len) {{
        memcpy(&parameters->{}, &buffer[position], {});
        position += {};
    }}
    else return -1;
    "#,
                    p.data_type.size(),
                    p.name, p.data_type.size(),
                    p.data_type.size()),

                    InstFeedbackParameterType::String =>format!(r#"
    if (position < len) {{
        int copy_len = (len) - position;
        // free buffer if not null
        if (parameters->{} != NULL) free(parameters->{});
        parameters->{} = (char*)malloc(copy_len+1);
        strncpy(parameters->{}, &buffer[position], copy_len);
        parameters->{}[copy_len] = 0; // Ensure last character is null
        position += copy_len;
    }}
    else return -1;
                    "#,
                    p.name,
                    p.name,
                    p.name,
                    p.name,
                    p.name),

                }
                
            }).collect::<Vec<String>>().join("\n").as_bytes()).unwrap();

            file.write_all(r#"
    return 0;
}
        "#.as_bytes()).unwrap();
    }
    });

    // Create a set of inline implementation for readability and debugging
    codes.codes.iter().for_each(|(k, code)| {
        if let Some(inst) = &code.instruction {
            file.write_all(format!(r#"
int parse_instruction_{}_frame(char* buffer, int len, struct s_inst_{}_params* parameters)
{{
    int position = 0;

    if ((buffer == NULL) || (len == NULL) || (parameters == NULL))
    return -1;

    // Check the code
    if (buffer[position++] != {}) return -1;
        "#,
            code.name.to_lowercase(),
            code.name.to_lowercase(),
            k
        ).as_bytes()).unwrap();

            file.write_all(inst.parameters.iter().map(|p| {
                match p.data_type {
                    InstFeedbackParameterType::Uint8 |
                    InstFeedbackParameterType::Int8 => format!(r#"
    if (position < len) parameters->{} = ({}) buffer[position++] ;
    else return -1;
    "#, p.name, p.data_type.to_cpp_type_string()),
                    InstFeedbackParameterType::Int16 |
                    InstFeedbackParameterType::Uint16 |
                    InstFeedbackParameterType::Int32 |
                    InstFeedbackParameterType::Uint32 |
                    InstFeedbackParameterType::Int64 |
                    InstFeedbackParameterType::Uint64 => format!(r#"
    if ((position + {}) < len) {{
        memcpy(&parameters->{}, &buffer[position], {});
        position += {};
    }}
    else return -1;
    "#,
                    p.data_type.size(),
                    p.name, p.data_type.size(),
                    p.data_type.size()),

                    InstFeedbackParameterType::String =>format!(r#"
    if (position < len) {{
        int copy_len = (len) - position;
        // free buffer if not null
        if (parameters->{} != NULL) free(parameters->{});
        parameters->{} = (char*)malloc(copy_len+1);
        strncpy(parameters->{}, &buffer[position], copy_len);
        parameters->{}[copy_len] = 0; // Ensure last character is null
        position += copy_len;
    }}
    else return -1;
                    "#,
                    p.name,
                    p.name,
                    p.name,
                    p.name,
                    p.name),

                }
                
            }).collect::<Vec<String>>().join("\n").as_bytes()).unwrap();

            file.write_all(r#"
    return 0;
}
        "#.as_bytes()).unwrap();
    }
    });


    /// To the frame decoding hub
    file.write_all(r#"
int parse_feedback_frame(char* buffer, int len, Feedbacks* code, void **parameters)
{
    if ((buffer == NULL) || (code == NULL) || (parameters == NULL))
        return -1;

    switch (buffer[0])
    {
    "#.as_bytes())?;

    codes.codes.iter().for_each(|(k, code)| {
        if code.feedback.is_some() {
            file.write_all(format!(r#"
        case {}:
            *parameters = malloc(sizeof(struct s_fb_{}_params));
            memset(*parameters, 0, sizeof(struct s_fb_{}_params));
            *code = FB_{};
            return parse_feedback_{}_frame(buffer, len, (struct s_fb_{}_params*)*parameters);
        "#, k, 
            code.name.to_lowercase(), 
            code.name.to_lowercase(),
            code.name.to_uppercase(),
            code.name.to_lowercase(),
            code.name.to_lowercase()
        ).as_bytes()).unwrap();
        }
    });

    file.write_all(r#"
    default: 
        return -1;
    }
}

    "#.as_bytes())?;


    file.write_all(r#"
int parse_instruction_frame(char* buffer, int len, Instructions* code, void **parameters)
{
    if ((buffer == NULL) || (code == NULL) || (parameters == NULL))
        return -1;

    switch (buffer[0])
    {
    "#.as_bytes())?;

    codes.codes.iter().for_each(|(k, code)| {
        if code.instruction.is_some() {
            file.write_all(format!(r#"
        case {}:
            *parameters = malloc(sizeof(struct s_inst_{}_params));
            memset(*parameters, 0, sizeof(struct s_inst_{}_params));
            *code = INST_{};
            return parse_instruction_{}_frame(buffer, len, (struct s_inst_{}_params*)*parameters);
        "#, k, 
            code.name.to_lowercase(), 
            code.name.to_lowercase(),
            code.name.to_uppercase(),
            code.name.to_lowercase(),
            code.name.to_lowercase()
        ).as_bytes()).unwrap();
        }
    });

    file.write_all(r#"
    default: 
        return -1;
    }
}

    "#.as_bytes())?;
//     file.write_all(&codes.codes.iter().filter_map(|(&id, code)| {
//         if let Some(code_fb) = &code.feedback {
//             let params = &code_fb.parameters.iter().map(|param| {
//                 [
//                     match param.data_type {
//                         InstFeedbackParameterType::Int8 |
//                         InstFeedbackParameterType::Uint8 => "&[".as_bytes(),
//                         InstFeedbackParameterType::String => "".as_bytes(),
//                         _ => "&".as_bytes()
//                     },
//                     param.name.as_bytes(),
//                 match param.data_type {
//                     InstFeedbackParameterType::Uint8 => "] as &[u8]".as_bytes(),
//                     InstFeedbackParameterType::Uint16 |
//                     InstFeedbackParameterType::Uint32 |
//                     InstFeedbackParameterType::Uint64 |
//                     InstFeedbackParameterType::Int64 |
//                     InstFeedbackParameterType::Int32 |
//                     InstFeedbackParameterType::Int16 => ".to_le_bytes()".as_bytes(),
//                     InstFeedbackParameterType::Int8 => " as u8]".as_bytes(),
//                     InstFeedbackParameterType::String => ".as_bytes()".as_bytes()
//                 }
//                 ].concat()
//             }).collect::<Vec<Vec<u8>>>().join(",".as_bytes());

//             Some(
//             [format!("Self::{}{{{}}} => vec![&[{}u8] as &[u8],",
//             &code.name,
//             code_fb.parameters.iter().map(|p| p.name.clone()).collect::<Vec<String>>().join(","), id).as_bytes(), params.as_slice(), "].concat()".as_bytes()].concat())
//         } else { None }
//     }).collect::<Vec<Vec<u8>>>().join(",\n\t\t\t".as_bytes()).as_slice())?;


//     file.write_all(r#"
//         }
//     }

//     pub fn from_bytes(bytes: &[u8]) -> Result<Self, ()> {
//         match bytes[0] {
//             "#.as_bytes())?;

//     file.write_all(&codes.codes.iter().filter_map(|(&id, code)| {
//         if let Some(code_fb) = &code.feedback {
//             let mut start = 1;
//             let params_parsing = &code_fb.parameters.iter().map(|param| {
//                 let data_len =  match param.data_type {
//                     InstFeedbackParameterType::Uint8 |
//                     InstFeedbackParameterType::Int8  => 1,
//                     InstFeedbackParameterType::Uint16 |
//                     InstFeedbackParameterType::Int16  => 2,
//                     InstFeedbackParameterType::Uint32 |
//                     InstFeedbackParameterType::Int32 => 4,
//                     InstFeedbackParameterType::Uint64 |
//                     InstFeedbackParameterType::Int64 => 8,
//                     InstFeedbackParameterType::String => -1
//                 };
//                 let res = [format!("let {} = ", param.name).as_bytes(),
//                 // Front content
//                 match param.data_type {
//                     InstFeedbackParameterType::Uint16 |
//                     InstFeedbackParameterType::Uint32 |
//                     InstFeedbackParameterType::Uint64 |
//                     InstFeedbackParameterType::Int64 |
//                     InstFeedbackParameterType::Int32 |
//                     InstFeedbackParameterType::Int16 => format!("{}::from_le_bytes(", param.data_type.to_rust_type_string()),
//                     InstFeedbackParameterType::String => "String::from_utf8(".into(),
//                     _ => "".into()
//                 }.as_bytes(),
//                 match data_len {
//                     -1 => format!("bytes[{}..]", start),
//                     1 => format!("bytes[{}]", start),
//                     _ =>  format!("bytes[{}..{}]", start, start+data_len),
//                 }.as_bytes(),
//                 // Back content
//                 match param.data_type {
//                     InstFeedbackParameterType::Uint16 |
//                     InstFeedbackParameterType::Uint32 |
//                     InstFeedbackParameterType::Uint64 |
//                     InstFeedbackParameterType::Int64 |
//                     InstFeedbackParameterType::Int32 |
//                     InstFeedbackParameterType::Int16 => ".try_into().unwrap())".as_bytes(),
//                     InstFeedbackParameterType::String => ".to_vec()).unwrap()".as_bytes(),
//                     InstFeedbackParameterType::Int8 => " as i8".as_bytes(),
//                     _ => "".as_bytes()
//                 },
//                 ";\n".as_bytes()
//                 ].concat();
//                 start = start + data_len;
//                 res
//             }).collect::<Vec<Vec<u8>>>().join("\t\t\t\t".as_bytes());

//             let params = &code_fb.parameters.iter().map(|param| {
//                 [param.name.as_bytes(),
//                 match param.data_type {
//                     InstFeedbackParameterType::Uint8 => "".as_bytes(),
//                     InstFeedbackParameterType::Uint16 |
//                     InstFeedbackParameterType::Uint32 |
//                     InstFeedbackParameterType::Uint64 |
//                     InstFeedbackParameterType::Int64 |
//                     InstFeedbackParameterType::Int32 |
//                     InstFeedbackParameterType::Int16 => ".to_le_bytes()".as_bytes(),
//                     InstFeedbackParameterType::Int8 => " as u8".as_bytes(),
//                     InstFeedbackParameterType::String => ".as_bytes()".as_bytes()
//                 }
//                 ].concat()
//             }).collect::<Vec<Vec<u8>>>().join(",".as_bytes());

//             Some(
//             format!(r#"{}u8 => {{
//                 {}
//                 Ok(Self::{}{{{}}})
//             }}
//                 "#,
//             id.to_string(),
//             String::from_utf8(params_parsing.clone()).unwrap(),
//             &code.name,
//             code_fb.parameters.iter().map(|name| name.name.clone()).collect::<Vec<String>>().join(", ")))
//         } else { None }
//     }).collect::<Vec<String>>().join(",\n\t\t\t").as_bytes())?;

//     file.write_all(r#",
//     _ => Err(())
//         }
//     }
// }

// impl Instructions {
//     pub fn to_bytes(self) -> Vec<u8> {
//         match self {
//     "#.as_bytes())?;


//     file.write_all(&codes.codes.iter().filter_map(|(&id, code)| {
//         if let Some(code_fb) = &code.instruction {
//             let params = &code_fb.parameters.iter().map(|param| {
//                 [
//                     match param.data_type {
//                         InstFeedbackParameterType::Int8 |
//                         InstFeedbackParameterType::Uint8 => "&[".as_bytes(),
//                         InstFeedbackParameterType::String => "".as_bytes(),
//                         _ => "&".as_bytes()
//                     },
//                     param.name.as_bytes(),
//                 match param.data_type {
//                     InstFeedbackParameterType::Uint8 => "] as &[u8]".as_bytes(),
//                     InstFeedbackParameterType::Uint16 |
//                     InstFeedbackParameterType::Uint32 |
//                     InstFeedbackParameterType::Uint64 |
//                     InstFeedbackParameterType::Int64 |
//                     InstFeedbackParameterType::Int32 |
//                     InstFeedbackParameterType::Int16 => ".to_le_bytes()".as_bytes(),
//                     InstFeedbackParameterType::Int8 => " as u8]".as_bytes(),
//                     InstFeedbackParameterType::String => ".as_bytes()".as_bytes()
//                 }
//                 ].concat()
//             }).collect::<Vec<Vec<u8>>>().join(",".as_bytes());

//             Some(
//             [format!("Self::{}{{{}}} => vec![&[{}u8] as &[u8],",
//             &code.name,
//             code_fb.parameters.iter().map(|p| p.name.clone()).collect::<Vec<String>>().join(","), id).as_bytes(), params.as_slice(), "].concat()".as_bytes()].concat())
//         } else { None }
//     }).collect::<Vec<Vec<u8>>>().join(",\n\t\t\t".as_bytes()).as_slice())?;


//     file.write_all(r#"
//         }
//     }

//     pub fn from_bytes(bytes: &[u8]) -> Result<Self, ()> {
//         match bytes[0] {
//             "#.as_bytes())?;

//     file.write_all(&codes.codes.iter().filter_map(|(&id, code)| {
//         if let Some(code_fb) = &code.instruction {
//             let mut start = 1;
//             let params_parsing = &code_fb.parameters.iter().map(|param| {
//                 let data_len =  match param.data_type {
//                     InstFeedbackParameterType::Uint8 |
//                     InstFeedbackParameterType::Int8  => 1,
//                     InstFeedbackParameterType::Uint16 |
//                     InstFeedbackParameterType::Int16  => 2,
//                     InstFeedbackParameterType::Uint32 |
//                     InstFeedbackParameterType::Int32 => 4,
//                     InstFeedbackParameterType::Uint64 |
//                     InstFeedbackParameterType::Int64 => 8,
//                     InstFeedbackParameterType::String => -1
//                 };
//                 let res = [format!("let {} = ", param.name).as_bytes(),
//                 // Front content
//                 match param.data_type {
//                     InstFeedbackParameterType::Uint16 |
//                     InstFeedbackParameterType::Uint32 |
//                     InstFeedbackParameterType::Uint64 |
//                     InstFeedbackParameterType::Int64 |
//                     InstFeedbackParameterType::Int32 |
//                     InstFeedbackParameterType::Int16 => format!("{}::from_le_bytes(", param.data_type.to_rust_type_string()),
//                     InstFeedbackParameterType::String => "String::from_utf8(".into(),
//                     _ => "".into()
//                 }.as_bytes(),
//                 match data_len {
//                     -1 => format!("bytes[{}..]", start),
//                     1 => format!("bytes[{}]", start),
//                     _ =>  format!("bytes[{}..{}]", start, start+data_len),
//                 }.as_bytes(),
//                 // Back content
//                 match param.data_type {
//                     InstFeedbackParameterType::Uint16 |
//                     InstFeedbackParameterType::Uint32 |
//                     InstFeedbackParameterType::Uint64 |
//                     InstFeedbackParameterType::Int64 |
//                     InstFeedbackParameterType::Int32 |
//                     InstFeedbackParameterType::Int16 => ".try_into().unwrap())".as_bytes(),
//                     InstFeedbackParameterType::String => ".to_vec()).unwrap()".as_bytes(),
//                     InstFeedbackParameterType::Int8 => " as i8".as_bytes(),
//                     _ => "".as_bytes()
//                 },
//                 ";\n".as_bytes()
//                 ].concat();
//                 start = start + data_len;
//                 res
//             }).collect::<Vec<Vec<u8>>>().join("\t\t\t\t".as_bytes());

//             let params = &code_fb.parameters.iter().map(|param| {
//                 [param.name.as_bytes(),
//                 match param.data_type {
//                     InstFeedbackParameterType::Uint8 => "".as_bytes(),
//                     InstFeedbackParameterType::Uint16 |
//                     InstFeedbackParameterType::Uint32 |
//                     InstFeedbackParameterType::Uint64 |
//                     InstFeedbackParameterType::Int64 |
//                     InstFeedbackParameterType::Int32 |
//                     InstFeedbackParameterType::Int16 => ".to_le_bytes()".as_bytes(),
//                     InstFeedbackParameterType::Int8 => " as u8".as_bytes(),
//                     InstFeedbackParameterType::String => ".as_bytes()".as_bytes()
//                 }
//                 ].concat()
//             }).collect::<Vec<Vec<u8>>>().join(",".as_bytes());

//             Some(
//             format!(r#"{}u8 => {{
//                 {}
//                 Ok(Self::{}{{{}}})
//             }}
//                 "#,
//             id.to_string(),
//             String::from_utf8(params_parsing.clone()).unwrap(),
//             &code.name,
//             code_fb.parameters.iter().map(|name| name.name.clone()).collect::<Vec<String>>().join(", ")))
//         } else { None }
//     }).collect::<Vec<String>>().join(",\n\t\t\t").as_bytes())?;

//     file.write_all(r#",
//     _ => Err(())
//         }
//     }
// }
// "#.as_bytes())?;

    Ok(())
}