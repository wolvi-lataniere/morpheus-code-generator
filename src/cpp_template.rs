
use crate::yaml_parser::{self, InstFeedbackParameterType};
use std::io::{self, Write};
use std::fs::File;
use std::path::Path;

const FILE_HEADER : &'static str = r#"
// This file is autogenerated, please do not edit manually
#include <stdint.h>
#include <string.h>
#include <stdlib.h>

"#;

pub fn build_cpp_header(header_file_name: &String, codes: &yaml_parser::CodesFile) -> Result<(), io::Error> {
    let mut file = File::create(&header_file_name)?;

    file.write_all(FILE_HEADER.as_bytes())?;

    // First, create the enumerations declaration.
    file.write_all(r#"
// Instructions Codes list
typedef enum __instructions_enum {
    "#.as_bytes())?;

    file.write_all(codes.codes.iter().filter_map(|(k, v)| 
       if v.instruction.is_some() { Some(format!("INST_{} = {}", v.name.to_uppercase(), k)) }
       else { None }
).collect::<Vec<String>>().join(",\n\t").as_bytes())?;

    file.write_all(r#"
} Instructions;


// Feedback codes list
typedef enum __feedbacks_enum {
    "#.as_bytes())?;

    file.write_all(codes.codes.iter().filter_map(|(k, v)| 
    if v.feedback.is_some() { Some(format!("FB_{} = {}", v.name.to_uppercase(), k)) }
    else { None }
).collect::<Vec<String>>().join(",\n\t").as_bytes())?;

    file.write_all(r#"
} Feedbacks;



"#.as_bytes())?;

    codes.codes.iter().for_each(|(_k, code)| {
        if let Some(inst) = &code.instruction {
            file.write_all(format!(r#"
struct s_inst_{}_params {{
    {}
}};
"#, 
                code.name.to_lowercase(),
                inst.parameters.iter().map(|p| {
                    format!("{} {};", p.data_type.to_cpp_type_string(), p.name)
                }).collect::<Vec<String>>().join("\n\t")
            ).as_bytes()).unwrap();
            }
        });

    
    codes.codes.iter().for_each(|(_k, code)| {
            if let Some(fb) = &code.feedback {
                file.write_all(format!(r#"
struct s_fb_{}_params {{
    {}
}};
    "#, 
                    code.name.to_lowercase(),
                    fb.parameters.iter().map(|p| {
                        format!("{} {};", p.data_type.to_cpp_type_string(), p.name)
                    }).collect::<Vec<String>>().join("\n\t")
                ).as_bytes()).unwrap();
                }
            });

    codes.codes.iter().for_each(|(_k,code)| {
        if code.feedback.is_some() {
            file.write_all(format!(r#"
int build_feedback_{}_frame(char* buffer, int *len, struct s_fb_{}_params* parameters);
"#, code.name.to_lowercase(), code.name.to_lowercase()).as_bytes()).unwrap();
        }
        if code.instruction.is_some() {
            file.write_all(format!(r#"
int build_instruction_{}_frame(char* buffer, int *len, struct s_inst_{}_params* parameters);
"#, code.name.to_lowercase(), code.name.to_lowercase()).as_bytes()).unwrap();
        }
    });

    file.write_all(r#"

    // External parsing functions
    extern int parse_feedback_frame(char* buffer, int len, Feedbacks* code, void **parameters);
    extern int parse_instruction_frame(char* buffer, int len, Instructions* code, void **parameters);"#.as_bytes())?;
    file.flush()?;

    Ok(())
}

pub fn build_cpp_source(source_file_name: &String, header_file: &Option<String>, codes: &yaml_parser::CodesFile) -> Result<(), io::Error> {
//// Create source code file
    let mut file = File::create(&source_file_name)?;

    file.write_all(FILE_HEADER.as_bytes())?;
    file.write_all(format!(r#"#include "{}"
#include <zephyr/zephyr.h>
"#, Path::new(&header_file.clone().unwrap_or(source_file_name.clone())).file_name().unwrap().to_str().unwrap().replace(".cpp", ".h").replace(".c", ".h")).as_bytes())?;
    
//     // Add to frame implementation
// Create a set of inline implementation for readability and debugging
    codes.codes.iter().for_each(|(k, code)| {
        if let Some(fb) = &code.feedback {
            file.write_all(format!(r#"
int build_feedback_{}_frame(char* buffer, int *len, struct s_fb_{}_params* parameters)
{{
    int position = 0;

    if ((buffer == NULL) || (len == NULL) || (parameters == NULL))
      return -1;
    
    if (position < *len) buffer[position++] = {};
    else return -1;
        "#,
            code.name.to_lowercase(),
            code.name.to_lowercase(),
            k
        ).as_bytes()).unwrap();

            file.write_all(fb.parameters.iter().map(|p| {
                match p.data_type {
                    InstFeedbackParameterType::Bool |
                    InstFeedbackParameterType::Uint8 |
                    InstFeedbackParameterType::Int8 => format!(r#"
    if (position < *len) buffer[position++] = (uint8_t) parameters->{};
    else return -1;
    "#, p.name),
                    InstFeedbackParameterType::Int16 |
                    InstFeedbackParameterType::Uint16 |
                    InstFeedbackParameterType::Int32 |
                    InstFeedbackParameterType::Uint32 |
                    InstFeedbackParameterType::Int64 |
                    InstFeedbackParameterType::Uint64 => format!(r#"
    if ((position + {}) < *len) {{
        memcpy(&buffer[position], &parameters->{}, {});
        position += {};
    }}
    else return -1;
    "#,
                    p.data_type.size(),
                    p.name, p.data_type.size(),
                    p.data_type.size()),

                    InstFeedbackParameterType::String =>format!(r#"
    if (position < *len) {{
        int max_len= (*len) - position;
        int string_len = strlen(parameters->{});
        if (string_len>max_len) string_len=max_len;
        memcpy(&buffer[position], parameters->{}, string_len);
        position += string_len;
    }}
    else return -1;
                    "#,
                    p.name,
                    p.name),

                }
                
            }).collect::<Vec<String>>().join("\n").as_bytes()).unwrap();

            file.write_all(r#"
    *len = position;

    return 0;
}
        "#.as_bytes()).unwrap();
    }
    });


    // Create a set of inline implementation for readability and debugging
    codes.codes.iter().for_each(|(k, code)| {
        if let Some(inst) = &code.instruction {
            file.write_all(format!(r#"
int build_instruction_{}_frame(char* buffer, int *len, struct s_inst_{}_params* parameters)
{{
    int position = 0;

    if ((buffer == NULL) || (len == NULL) || (parameters == NULL))
      return -1;
    
    if (position < *len) buffer[position++] = {};
    else return -1;
        "#,
            code.name.to_lowercase(),
            code.name.to_lowercase(),
            k
        ).as_bytes()).unwrap();

            file.write_all(inst.parameters.iter().map(|p| {
                match p.data_type {
                    InstFeedbackParameterType::Bool |
                    InstFeedbackParameterType::Uint8 |
                    InstFeedbackParameterType::Int8 => format!(r#"
    if (position < *len) buffer[position++] = (uint8_t) parameters->{};
    else return -1;
    "#, p.name),
                    InstFeedbackParameterType::Int16 |
                    InstFeedbackParameterType::Uint16 |
                    InstFeedbackParameterType::Int32 |
                    InstFeedbackParameterType::Uint32 |
                    InstFeedbackParameterType::Int64 |
                    InstFeedbackParameterType::Uint64 => format!(r#"
    if ((position + {}) < *len) {{
        memcpy(&buffer[position], &parameters->{}, {});
        position += {};
    }}
    else return -1;
    "#,
                    p.data_type.size(),
                    p.name, p.data_type.size(),
                    p.data_type.size()),

                    InstFeedbackParameterType::String =>format!(r#"
    if (position < *len) {{
        int max_len= (*len) - position;
        int string_len = strlen(parameters->{});
        if (string_len>max_len) string_len=max_len;
        memcpy(&buffer[position], parameters->{}, string_len);
        position += string_len;
    }}
    else return -1;
                    "#,
                    p.name,
                    p.name),

                }
                
            }).collect::<Vec<String>>().join("\n").as_bytes()).unwrap();

            file.write_all(r#"
    *len = position;

    return 0;
}
        "#.as_bytes()).unwrap();
    }
    });


//     // Add to frame decoding
// Create a set of inline implementation for readability and debugging
    codes.codes.iter().for_each(|(k, code)| {
        if let Some(fb) = &code.feedback {
            file.write_all(format!(r#"
int parse_feedback_{}_frame(char* buffer, int len, struct s_fb_{}_params* parameters)
{{
    int position = 0;
    const size_t p_size = sizeof(struct s_fb_{}_params);


    if (buffer == NULL)
        return -1;

    if ((p_size > 0) && (parameters == NULL))
        return -1;
        
    // Check the code
    if (buffer[position++] != {}) return -1;
        "#,
            code.name.to_lowercase(),
            code.name.to_lowercase(),
            code.name.to_lowercase(),
            k
        ).as_bytes()).unwrap();

            file.write_all(fb.parameters.iter().map(|p| {
                match p.data_type {
                    InstFeedbackParameterType::Bool =>
                    format!(r#"
    if (position < len) parameters->{} = (buffer[position++] != 0) ;
    else return -1;
    "#, p.name),
                    InstFeedbackParameterType::Uint8 |
                    InstFeedbackParameterType::Int8 => format!(r#"
    if (position < len) parameters->{} = ({}) buffer[position++] ;
    else return -1;
    "#, p.name, p.data_type.to_cpp_type_string()),
                    InstFeedbackParameterType::Int16 |
                    InstFeedbackParameterType::Uint16 |
                    InstFeedbackParameterType::Int32 |
                    InstFeedbackParameterType::Uint32 |
                    InstFeedbackParameterType::Int64 |
                    InstFeedbackParameterType::Uint64 => format!(r#"
    if ((position + {}) < len) {{
        memcpy(&parameters->{}, &buffer[position], {});
        position += {};
    }}
    else return -1;
    "#,
                    p.data_type.size(),
                    p.name, p.data_type.size(),
                    p.data_type.size()),

                    InstFeedbackParameterType::String =>format!(r#"
    if (position < len) {{
        int copy_len = (len) - position;
        // free buffer if not null
        if (parameters->{} != NULL) k_free(parameters->{});
        parameters->{} = (char*)k_malloc(copy_len+1);
        strncpy(parameters->{}, &buffer[position], copy_len);
        parameters->{}[copy_len] = 0; // Ensure last character is null
        position += copy_len;
    }}
    else return -1;
                    "#,
                    p.name,
                    p.name,
                    p.name,
                    p.name,
                    p.name),

                }
                
            }).collect::<Vec<String>>().join("\n").as_bytes()).unwrap();

            file.write_all(r#"
    return 0;
}
        "#.as_bytes()).unwrap();
    }
    });

    // Create a set of inline implementation for readability and debugging
    codes.codes.iter().for_each(|(k, code)| {
        if let Some(inst) = &code.instruction {
            file.write_all(format!(r#"
int parse_instruction_{}_frame(char* buffer, int len, struct s_inst_{}_params* parameters)
{{
    int position = 0;
    const size_t p_size = sizeof(struct s_inst_{}_params);


    if (buffer == NULL)
        return -1;

    if ((p_size > 0) && (parameters == NULL))
        return -1;

    // Check the code
    if (buffer[position++] != {}) return -1;
        "#,
            code.name.to_lowercase(),
            code.name.to_lowercase(),
            code.name.to_lowercase(),
            k
        ).as_bytes()).unwrap();

            file.write_all(inst.parameters.iter().map(|p| {
                match p.data_type {
                    InstFeedbackParameterType::Bool => format!(r#"
    if (position < len) parameters->{} = (buffer[position++] != 0);
    else return -1;
    "#, p.name),
                    InstFeedbackParameterType::Uint8 |
                    InstFeedbackParameterType::Int8 => format!(r#"
    if (position < len) parameters->{} = ({}) buffer[position++] ;
    else return -1;
    "#, p.name, p.data_type.to_cpp_type_string()),
                    InstFeedbackParameterType::Int16 |
                    InstFeedbackParameterType::Uint16 |
                    InstFeedbackParameterType::Int32 |
                    InstFeedbackParameterType::Uint32 |
                    InstFeedbackParameterType::Int64 |
                    InstFeedbackParameterType::Uint64 => format!(r#"
    if ((position + {}) < len) {{
        memcpy(&parameters->{}, &buffer[position], {});
        position += {};
    }}
    else return -1;
    "#,
                    p.data_type.size(),
                    p.name, p.data_type.size(),
                    p.data_type.size()),

                    InstFeedbackParameterType::String =>format!(r#"
    if (position < len) {{
        int copy_len = (len) - position;
        // free buffer if not null
        if (parameters->{} != NULL) k_free(parameters->{});
        parameters->{} = (char*)k_malloc(copy_len+1);
        strncpy(parameters->{}, &buffer[position], copy_len);
        parameters->{}[copy_len] = 0; // Ensure last character is null
        position += copy_len;
    }}
    else return -1;
                    "#,
                    p.name,
                    p.name,
                    p.name,
                    p.name,
                    p.name),

                }
                
            }).collect::<Vec<String>>().join("\n").as_bytes()).unwrap();

            file.write_all(r#"
    return 0;
}
        "#.as_bytes()).unwrap();
    }
    });


    /// To the frame decoding hub
    file.write_all(r#"
int parse_feedback_frame(char* buffer, int len, Feedbacks* code, void **parameters)
{
    if ((buffer == NULL) || (code == NULL) || (parameters == NULL))
        return -1;

    switch (buffer[0])
    {
    "#.as_bytes())?;

    codes.codes.iter().for_each(|(k, code)| {
        if code.feedback.is_some() {
            file.write_all(format!(r#"
        case {}:
            {{
                const size_t psize = sizeof(struct s_fb_{}_params);
                *parameters = k_malloc(psize);
                memset(*parameters, 0, psize);
                *code = FB_{};
                return parse_feedback_{}_frame(buffer, len, (struct s_fb_{}_params*)*parameters);
            }}
        "#, k, 
            code.name.to_lowercase(),
            code.name.to_uppercase(),
            code.name.to_lowercase(),
            code.name.to_lowercase()
        ).as_bytes()).unwrap();
        }
    });

    file.write_all(r#"
    default: 
        return -1;
    }
}

    "#.as_bytes())?;


    file.write_all(r#"
int parse_instruction_frame(char* buffer, int len, Instructions* code, void **parameters)
{
    if ((buffer == NULL) || (code == NULL) || (parameters == NULL))
        return -1;

    switch (buffer[0])
    {
    "#.as_bytes())?;

    codes.codes.iter().for_each(|(k, code)| {
        if code.instruction.is_some() {
            file.write_all(format!(r#"
        case {}:
            {{
                const size_t psize = sizeof(struct s_inst_{}_params);
                *parameters = k_malloc(psize);
                memset(*parameters, 0, psize);
                *code = INST_{};
                return parse_instruction_{}_frame(buffer, len, (struct s_inst_{}_params*)*parameters);
            }}
        "#, k, 
            code.name.to_lowercase(),
            code.name.to_uppercase(),
            code.name.to_lowercase(),
            code.name.to_lowercase()
        ).as_bytes()).unwrap();
        }
    });

    file.write_all(r#"
    default: 
        return -1;
    }
}

    "#.as_bytes())?;
    Ok(())
}
